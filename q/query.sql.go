// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package q

import (
	"context"

	uuid "github.com/gofrs/uuid/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

const countSubjectPatchesByStates = `-- name: CountSubjectPatchesByStates :one
select count(1)
from subject_patch
where deleted_at is null
  and state = any ($1::int[])
`

func (q *Queries) CountSubjectPatchesByStates(ctx context.Context, dollar_1 []int32) (int64, error) {
	row := q.db.QueryRow(ctx, countSubjectPatchesByStates, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createComment = `-- name: CreateComment :exec
insert into edit_suggestion (id,
                             patch_id,
                             patch_type,
                             text,
                             from_user,
                             created_at,
                             deleted_at)
values ($1, $2, $3, $4, $5, current_timestamp, null)
`

type CreateCommentParams struct {
	ID        uuid.UUID
	PatchID   uuid.UUID
	PatchType PatchType
	Text      string
	FromUser  int32
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) error {
	_, err := q.db.Exec(ctx, createComment,
		arg.ID,
		arg.PatchID,
		arg.PatchType,
		arg.Text,
		arg.FromUser,
	)
	return err
}

const createSubjectEditPatch = `-- name: CreateSubjectEditPatch :exec
INSERT INTO subject_patch
(id, subject_id, from_user_id, reason, name, infobox, summary, nsfw,
 original_name, original_infobox, original_summary, subject_type, patch_desc)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type CreateSubjectEditPatchParams struct {
	ID              uuid.UUID
	SubjectID       int32
	FromUserID      int32
	Reason          string
	Name            pgtype.Text
	Infobox         pgtype.Text
	Summary         pgtype.Text
	Nsfw            pgtype.Bool
	OriginalName    string
	OriginalInfobox pgtype.Text
	OriginalSummary pgtype.Text
	SubjectType     int64
	PatchDesc       string
}

func (q *Queries) CreateSubjectEditPatch(ctx context.Context, arg CreateSubjectEditPatchParams) error {
	_, err := q.db.Exec(ctx, createSubjectEditPatch,
		arg.ID,
		arg.SubjectID,
		arg.FromUserID,
		arg.Reason,
		arg.Name,
		arg.Infobox,
		arg.Summary,
		arg.Nsfw,
		arg.OriginalName,
		arg.OriginalInfobox,
		arg.OriginalSummary,
		arg.SubjectType,
		arg.PatchDesc,
	)
	return err
}

const getComments = `-- name: GetComments :many
select edit_suggestion.id, edit_suggestion.patch_id, edit_suggestion.patch_type, edit_suggestion.text, edit_suggestion.from_user, edit_suggestion.created_at, edit_suggestion.deleted_at, author.user_id, author.username, author.nickname
from edit_suggestion
         left join patch_users as author on author.user_id = edit_suggestion.from_user
where deleted_at is null
  and patch_id = $1
  and patch_type = $2
  and deleted_at is null
order by created_at
`

type GetCommentsParams struct {
	PatchID   uuid.UUID
	PatchType PatchType
}

type GetCommentsRow struct {
	ID        uuid.UUID
	PatchID   uuid.UUID
	PatchType PatchType
	Text      string
	FromUser  int32
	CreatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
	UserID    pgtype.Int4
	Username  pgtype.Text
	Nickname  pgtype.Text
}

func (q *Queries) GetComments(ctx context.Context, arg GetCommentsParams) ([]GetCommentsRow, error) {
	rows, err := q.db.Query(ctx, getComments, arg.PatchID, arg.PatchType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsRow
	for rows.Next() {
		var i GetCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PatchID,
			&i.PatchType,
			&i.Text,
			&i.FromUser,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Username,
			&i.Nickname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodePatch = `-- name: GetEpisodePatch :one
SELECT id, episode_id, state, from_user_id, wiki_user_id, reason, original_name, name, original_name_cn, name_cn, original_duration, duration, original_airdate, airdate, original_description, description, created_at, updated_at, deleted_at, reject_reason, comments_count, patch_desc, ep
FROM episode_patch
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetEpisodePatch(ctx context.Context, id uuid.UUID) (EpisodePatch, error) {
	row := q.db.QueryRow(ctx, getEpisodePatch, id)
	var i EpisodePatch
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.State,
		&i.FromUserID,
		&i.WikiUserID,
		&i.Reason,
		&i.OriginalName,
		&i.Name,
		&i.OriginalNameCn,
		&i.NameCn,
		&i.OriginalDuration,
		&i.Duration,
		&i.OriginalAirdate,
		&i.Airdate,
		&i.OriginalDescription,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.RejectReason,
		&i.CommentsCount,
		&i.PatchDesc,
		&i.Ep,
	)
	return i, err
}

const getSubjectPatchByID = `-- name: GetSubjectPatchByID :one
select id, subject_id, state, from_user_id, wiki_user_id, reason, name, original_name, infobox, original_infobox, summary, original_summary, nsfw, created_at, updated_at, deleted_at, reject_reason, subject_type, comments_count, patch_desc, original_platform, platform, action
from subject_patch
where deleted_at is null
  and id = $1
limit 1
`

func (q *Queries) GetSubjectPatchByID(ctx context.Context, id uuid.UUID) (SubjectPatch, error) {
	row := q.db.QueryRow(ctx, getSubjectPatchByID, id)
	var i SubjectPatch
	err := row.Scan(
		&i.ID,
		&i.SubjectID,
		&i.State,
		&i.FromUserID,
		&i.WikiUserID,
		&i.Reason,
		&i.Name,
		&i.OriginalName,
		&i.Infobox,
		&i.OriginalInfobox,
		&i.Summary,
		&i.OriginalSummary,
		&i.Nsfw,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.RejectReason,
		&i.SubjectType,
		&i.CommentsCount,
		&i.PatchDesc,
		&i.OriginalPlatform,
		&i.Platform,
		&i.Action,
	)
	return i, err
}

const getSubjectPatchByIDForUpdate = `-- name: GetSubjectPatchByIDForUpdate :one
select id, subject_id, state, from_user_id, wiki_user_id, reason, name, original_name, infobox, original_infobox, summary, original_summary, nsfw, created_at, updated_at, deleted_at, reject_reason, subject_type, comments_count, patch_desc, original_platform, platform, action
from subject_patch
where deleted_at is null
  and id = $1
limit 1 for update
`

func (q *Queries) GetSubjectPatchByIDForUpdate(ctx context.Context, id uuid.UUID) (SubjectPatch, error) {
	row := q.db.QueryRow(ctx, getSubjectPatchByIDForUpdate, id)
	var i SubjectPatch
	err := row.Scan(
		&i.ID,
		&i.SubjectID,
		&i.State,
		&i.FromUserID,
		&i.WikiUserID,
		&i.Reason,
		&i.Name,
		&i.OriginalName,
		&i.Infobox,
		&i.OriginalInfobox,
		&i.Summary,
		&i.OriginalSummary,
		&i.Nsfw,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.RejectReason,
		&i.SubjectType,
		&i.CommentsCount,
		&i.PatchDesc,
		&i.OriginalPlatform,
		&i.Platform,
		&i.Action,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
select user_id, username, nickname
from patch_users
where user_id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userID int32) (PatchUser, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i PatchUser
	err := row.Scan(&i.UserID, &i.Username, &i.Nickname)
	return i, err
}

const listSubjectPatchesByStates = `-- name: ListSubjectPatchesByStates :many
select subject_patch.id, subject_patch.subject_id, subject_patch.state, subject_patch.from_user_id, subject_patch.wiki_user_id, subject_patch.reason, subject_patch.name, subject_patch.original_name, subject_patch.infobox, subject_patch.original_infobox, subject_patch.summary, subject_patch.original_summary, subject_patch.nsfw, subject_patch.created_at, subject_patch.updated_at, subject_patch.deleted_at, subject_patch.reject_reason, subject_patch.subject_type, subject_patch.comments_count, subject_patch.patch_desc, subject_patch.original_platform, subject_patch.platform, subject_patch.action,
       author.user_id    as author_user_id,
       author.username   as author_username,
       author.nickname   as author_nickname,
       reviewer.user_id  as reviewer_user_id,
       reviewer.username as reviewer_username,
       reviewer.nickname as reviewer_nickname
from subject_patch
         inner join patch_users as author on author.user_id = subject_patch.from_user_id
         left outer join patch_users as reviewer on reviewer.user_id = subject_patch.wiki_user_id
where deleted_at is null
  and state = any ($1::int[])
order by created_at desc
limit $3::int8 offset $2::int8
`

type ListSubjectPatchesByStatesParams struct {
	State []int32
	Skip  int64
	Size  int64
}

type ListSubjectPatchesByStatesRow struct {
	ID               uuid.UUID
	SubjectID        int32
	State            int32
	FromUserID       int32
	WikiUserID       int32
	Reason           string
	Name             pgtype.Text
	OriginalName     string
	Infobox          pgtype.Text
	OriginalInfobox  pgtype.Text
	Summary          pgtype.Text
	OriginalSummary  pgtype.Text
	Nsfw             pgtype.Bool
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	DeletedAt        pgtype.Timestamptz
	RejectReason     string
	SubjectType      int64
	CommentsCount    int32
	PatchDesc        string
	OriginalPlatform pgtype.Int4
	Platform         pgtype.Int4
	Action           pgtype.Int4
	AuthorUserID     int32
	AuthorUsername   string
	AuthorNickname   string
	ReviewerUserID   pgtype.Int4
	ReviewerUsername pgtype.Text
	ReviewerNickname pgtype.Text
}

func (q *Queries) ListSubjectPatchesByStates(ctx context.Context, arg ListSubjectPatchesByStatesParams) ([]ListSubjectPatchesByStatesRow, error) {
	rows, err := q.db.Query(ctx, listSubjectPatchesByStates, arg.State, arg.Skip, arg.Size)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSubjectPatchesByStatesRow
	for rows.Next() {
		var i ListSubjectPatchesByStatesRow
		if err := rows.Scan(
			&i.ID,
			&i.SubjectID,
			&i.State,
			&i.FromUserID,
			&i.WikiUserID,
			&i.Reason,
			&i.Name,
			&i.OriginalName,
			&i.Infobox,
			&i.OriginalInfobox,
			&i.Summary,
			&i.OriginalSummary,
			&i.Nsfw,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.RejectReason,
			&i.SubjectType,
			&i.CommentsCount,
			&i.PatchDesc,
			&i.OriginalPlatform,
			&i.Platform,
			&i.Action,
			&i.AuthorUserID,
			&i.AuthorUsername,
			&i.AuthorNickname,
			&i.ReviewerUserID,
			&i.ReviewerUsername,
			&i.ReviewerNickname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectSubjectPatch = `-- name: RejectSubjectPatch :exec
update subject_patch
set wiki_user_id = $1,
    state        = $2,
    updated_at   = current_timestamp
where id = $3
  and deleted_at is null
  and state = 0
`

type RejectSubjectPatchParams struct {
	WikiUserID int32
	State      int32
	ID         uuid.UUID
}

func (q *Queries) RejectSubjectPatch(ctx context.Context, arg RejectSubjectPatchParams) error {
	_, err := q.db.Exec(ctx, rejectSubjectPatch, arg.WikiUserID, arg.State, arg.ID)
	return err
}

const updateSubjectPatchCommentCount = `-- name: UpdateSubjectPatchCommentCount :exec
update subject_patch
set comments_count = (select count(1)
                      from edit_suggestion
                      where patch_type = 'subject'
                        and patch_id = $1
                        and edit_suggestion.from_user != 0)
where id = $1
  and deleted_at is null
`

func (q *Queries) UpdateSubjectPatchCommentCount(ctx context.Context, patchID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateSubjectPatchCommentCount, patchID)
	return err
}

const upsertUser = `-- name: UpsertUser :exec
insert into patch_users (user_id, username, nickname)
VALUES ($1, $2, $3)
on conflict (user_id) do update set username = excluded.username,
                                    nickname = excluded.nickname
`

type UpsertUserParams struct {
	UserID   int32
	Username string
	Nickname string
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) error {
	_, err := q.db.Exec(ctx, upsertUser, arg.UserID, arg.Username, arg.Nickname)
	return err
}
